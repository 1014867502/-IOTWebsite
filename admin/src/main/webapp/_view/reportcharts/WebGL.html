<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>使用WebGL绘制一个点</title>
    <!--引入three.js三维引擎-->
    <script src="/assets/lib/3d/three.js"></script>
    <script src="/assets/lib/3d/controls/OrbitControls.js"></script>
</head>
<body>
    <!--canvas标签创建一个宽高均为500像素，背景为蓝色的矩形画布-->
    <canvas id="webgl" width="500" height="500" style="background-color: blue"></canvas>
    <!-- 顶点着色器源码 -->
    <script id="vertexShader" type="x-shader/x-vertex">
       //void main() {
             //给内置变量gl_PointSize赋值像素大小
             //gl_PointSize=20.0;
             //顶点位置，位于坐标原点
             //gl_Position =vec4(0.0,0.0,0.0,1.0);
       //}
       //attribute声明vec4类型变量apos
       attribute vec4 apos;
       attribute vec4 a_color; //attribute声明顶点颜色变量
       varying vec4 v_color;   //varying声明顶点颜色插值后变量

       void main() {
             //顶点坐标apos赋值给内置变量gl_Position
             //逐顶点处理数据
             //gl_Position = apos;
             // 在顶点着色器中逐顶点沿着x轴平移-0.4
             float radian = radians(45.0);
             float cos = cos(radian);
             float sin = sin(radian);
             mat4 mx = mat4(1,0,0,0,  0,cos,-sin,0,  0,sin,cos,0,  0,0,0,1);
             mat4 my = mat4(cos,0,-sin,0,  0,1,0,0,  sin,0,cos,0,  0,0,0,1);
             gl_Position = mx*my*apos;
             //gl_Position =vec4(apos.x-0.4,apos.y,apos.z,1);

             v_color = a_color; //顶点颜色插值计算
       }
    </script>
    <!-- 片元着色器源码 -->
    <script id="fragmentShader" type="x-shader/x-fragment">
        precision lowp float; //所有float类型数据的精度是lowp
        varying vec4 v_color; //接收顶点着色器中v_color数据
       void main() {
             //gl_FragColor = vec4(1.0,0.0,0.0,1.0);
             gl_FragColor = v_color;
       }
    </script>
    <script>
    //通过getElementById()方法获取canvas画布
    var canvas=document.getElementById('webgl');
    //通过方法getContext()获取WebGL上下文
    var gl=canvas.getContext('webgl');
    //顶点着色器源码
    var vertexShaderSource = document.getElementById('vertexShader').innerText;
    //片元着色器源码
    var fragShaderSource = document.getElementById('fragmentShader').innerText;
    //初始化着色器
    var program = initShader(gl,vertexShaderSource,fragShaderSource);
    //开始绘制，显示器显示结果
    //获取顶点着色器的位置变量apos，即aposLocation指向apos变量。
    var aposLocation = gl.getAttribLocation(program,'apos');
    var a_color = gl.getAttribLocation(program,'a_color');

    //9个元素构建三个顶点的xyz坐标值
    // 数组里9个元素，每间隔3个为一组，分别代表xyz轴上的坐标值
    //9个元素构建三个顶点的xyz坐标值
    var data=new Float32Array([
        0.5,  0.5,  0.5,//顶点0
        -0.5,  0.5,  0.5,//顶点1
        -0.5, -0.5,  0.5,//顶点2
        0.5, -0.5,  0.5,//顶点3
        0.5,  0.5, -0.5,//顶点4
        -0.5,  0.5, -0.5,//顶点5
        -0.5, -0.5, -0.5,//顶点6
        0.5, -0.5, -0.5,//顶点7
    ]);
    // 顶点索引数组
    var indexes = new Uint8Array([
        //前四个点对应索引值
        0, 1, 2, 3,//gl.LINE_LOOP模式四个点绘制一个矩形框
        //后四个顶点对应索引值
        4, 5, 6, 7,//gl.LINE_LOOP模式四个点绘制一个矩形框
        //前后对应点对应索引值
        0, 4,//两个点绘制一条直线
        1, 5,//两个点绘制一条直线
        2, 6,//两个点绘制一条直线
        3, 7,//两个点绘制一条直线
        0,2,1,
        0,2,3,
        2,5,1,
        2,5,6,
        4,6,5,
        4,6,7,
        6,3,2,
        6,3,7,
        1,4,0,
        1,4,5
    ]);

    /**
     * 创建顶点颜色数组colorData
     * */

    // var colorData = new Float32Array([
    //     1,0,0, 0,1,0, 0,0,1, 1,0,0, 1,0,0, 1,0,0,//红色——面1
    //     0,1,0, 0,1,0, 0,1,0, 0,1,0, 0,1,0, 0,1,0,//绿色——面2
    //     0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1,//蓝色——面3
    //     1,1,0, 1,1,0, 1,1,0, 1,1,0, 1,1,0, 1,1,0,//黄色——面4
    //     0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0,//黑色——面5
    //     1,1,1, 1,1,1, 1,1,1, 1,1,1, 1,1,1, 1,1,1 //白色——面6
    //     ]);

    var colorData = new Float32Array([
        1,0,0, 0,1,0, 0,0,1, 1,1,0, 0,0,0, 1,1,1,      //红色——面1
        .5,.6,0.7, .9,0.8,0.7//R=0.9——面2
    ]);

    /**
     创建缓冲区colorBuffer，传入顶点颜色数据colorData
     **/
    var colorBuffer=gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER,colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER,colorData,gl.STATIC_DRAW);
    gl.vertexAttribPointer(a_color,3,gl.FLOAT,false,0,0);
    gl.enableVertexAttribArray(a_color);

    //var data=new Float32Array([0.5,0.5,-0.5,0.5,-0.5,-0.5,0.5,-0.5]);
    //创建缓冲区对象
    var buffer=gl.createBuffer();
    //绑定缓冲区对象,激活buffer
    gl.bindBuffer(gl.ARRAY_BUFFER,buffer);
    //顶点数组data数据传入缓冲区
    gl.bufferData(gl.ARRAY_BUFFER,data,gl.STATIC_DRAW);
    //绑定缓冲区对象

    //创建缓冲区对象
    var indexesBuffer=gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexesBuffer);
    //索引数组indexes数据传入缓冲区
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,indexes,gl.STATIC_DRAW);

    //缓冲区中的数据按照一定的规律传递给位置变量apos
    gl.vertexAttribPointer(aposLocation,3,gl.FLOAT,false,0,0);
    //允许数据传递
    gl.enableVertexAttribArray(aposLocation);

    //gl.drawArrays(gl.LINE_LOOP,0,4);
    //gl.drawArrays(gl.LINE_LOOP,4,4);
    //gl.drawArrays(gl.LINES,8,8);
    //LINE_LOOP模式绘制前四个点
    gl.drawElements(gl.LINE_LOOP,4,gl.UNSIGNED_BYTE,0);
    //LINE_LOOP模式从第五个点开始绘制四个点
    gl.drawElements(gl.LINE_LOOP,4,gl.UNSIGNED_BYTE,4);
    //LINES模式绘制后8个点
    gl.drawElements(gl.LINES, 8, gl.UNSIGNED_BYTE, 8);
    //gl.drawArrays(gl.POINTS,0,1);
    /**执行绘制之前，一定要开启深度测试，以免颜色混乱**/
    gl.enable(gl.DEPTH_TEST);

    gl.drawElements( gl.TRIANGLES, 30, gl.UNSIGNED_BYTE, 16);

    //声明初始化着色器函数
    function initShader(gl,vertexShaderSource,fragmentShaderSource){
        //创建顶点着色器对象
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        //创建片元着色器对象
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        //引入顶点、片元着色器源代码
        gl.shaderSource(vertexShader,vertexShaderSource);
        gl.shaderSource(fragmentShader,fragmentShaderSource);
        //编译顶点、片元着色器
        gl.compileShader(vertexShader);
        gl.compileShader(fragmentShader);

        //创建程序对象program
        var program = gl.createProgram();
        //附着顶点着色器和片元着色器到program
        gl.attachShader(program,vertexShader);
        gl.attachShader(program,fragmentShader);
        //链接program
        gl.linkProgram(program);
        //使用program
        gl.useProgram(program);
        //返回程序program对象
        return program;
      }
 </script>
</body>
</html>