<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <!--引入three.js三维引擎-->
    <script src="/assets/lib/3d/three.js"></script>
    <script src="/assets/lib/3d/controls/OrbitControls.js"></script>
    <script src="/assets/lib/3d/loaders/OBJLoader.js"></script>
    <script src="/assets/lib/3d/loaders/MTLLoader.js"></script>
    <script src="/assets/lib/3d/renderers/CSS2DRenderer.js"></script>
    <script src="/assets/lib/3d/postprocessing/EffectComposer.js"></script>
    <script src="/assets/lib/3d/postprocessing/RenderPass.js"></script>
    <script src="/assets/lib/3d/postprocessing/ShaderPass.js"></script>
    <script src="/assets/lib/3d/shaders/CopyShader.js"></script>
    <script src="/assets/lib/3d/postprocessing/OutlinePass.js"></script>
    <script src="/assets/lib/3d/shaders/FXAAShader.js"></script>
</head>
<body>
<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec4 orientation;
    attribute vec3 offset;
    attribute vec2 scale;
    attribute float life;
    attribute float random;
    varying vec2 vUv;
    varying float vRandom;
    varying float vAlpha;
    float range(float oldValue, float oldMin, float oldMax, float newMin, float newMax)
    {
        float oldRange = oldMax - oldMin;
        float newRange = newMax - newMin;
        return (((oldValue - oldMin) * newRange) / oldRange) + newMin;
    }
    float pcurve(float x, float a, float b)
    {
        float k = pow(a + b, a + b) / (pow(a, a) * pow(b, b));
        return k * pow(x, a) * pow(1.0 - x, b);
    }
    void main() {
        vUv = uv;
        vRandom = random;
        vAlpha = pcurve(life, 1.0, 2.0);
        vec3 pos = position;
        pos.xy *= scale * vec2(range(pow(life, 1.5), 0.0, 1.0, 1.0, 0.6), range(pow(life, 1.5), 0.0, 1.0, 0.6, 1.2));
        vec4 or = orientation;
        vec3 vcV = cross(or.xyz, pos);
        pos = vcV * (2.0 * or.w) + (cross(or.xyz, vcV) * 2.0 + pos);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
    uniform sampler2D uMap;
    uniform vec3 uColor1;
    uniform vec3 uColor2;
    uniform float uTime;
    varying vec2 vUv;
    varying float vAlpha;
    varying float vRandom;
    void main()
    {
        vec2 uv = vUv;
        float spriteLength = 10.0;
        uv.x /= spriteLength;
        float spriteIndex = mod(uTime * 0.1 + vRandom * 2.0, 1.0);
        uv.x += floor(spriteIndex * spriteLength) / spriteLength;
        vec4 map = texture2D(uMap, uv);
        gl_FragColor.rgb = mix(uColor2, uColor1, map.r);
        gl_FragColor.a = vAlpha * map.a;
    }
</script>
<script>
    var scene=new THREE.Scene();
    var onProgress = function ( xhr ) {
        if ( xhr.lengthComputable ) {
            var percentComplete = xhr.loaded / xhr.total * 100;
            console.log( Math.round( percentComplete, 2 ) + '% downloaded' );
        }
    };
    var onError = function(xhr) {};
    var mtlLoader = new THREE.MTLLoader();
    mtlLoader.load('/img/粮仓模型/test3.mtl', function(materials) {
        materials.preload();


        var objLoader = new THREE.OBJLoader();
        objLoader.setMaterials(materials);
        objLoader.load('/img/粮仓模型/test3.obj', function(object) {
            //object.position.y = 3.5;
            object.scale.set(1, 1, 1);
            scene.add(object);
            console.log(object);
        }, onProgress, onError);
    });

    var axesHelper=new THREE.AxesHelper(500);
    var directionalLight=new THREE.DirectionalLight(0xffffff,0.7);
    directionalLight.position.set(1000,500,350);
    scene.add(directionalLight);
    var directionalLight2=new THREE.DirectionalLight(0xffffff,0.5);
    directionalLight2.position.set(500,300,-350);
    //scene.add(directionalLight2);
    var ambient=new THREE.AmbientLight(0xffffff,0.6);
    scene.add(ambient);
    var width=window.innerWidth;
    var height=window.innerHeight;
    var k=width/height;
    var s=200;
    var camera=new THREE.OrthographicCamera(-s*k,s*k,s,-s,1,1000);
    camera.position.set(730,130,-32);
    camera.lookAt(scene.position);
    var renderer=new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(width,height);
    renderer.setClearColor(0x409EFF,1);
    document.body.appendChild(renderer.domElement);
    var labelRenderer=new THREE.CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth,window.innerHeight);
    labelRenderer.domElement.style.position='absolute';
    labelRenderer.domElement.style.top='0';
    labelRenderer.domElement.style.pointerEvents='none';
    document.body.appendChild(labelRenderer.domElement);
    var renderPass=new THREE.RenderPass(scene,camera);
    var OutlinePass=new THREE.OutlinePass(
        new THREE.Vector2(window.innerWidth,window.innerHeight),scene,camera);
    OutlinePass.visibleEdgeColor=new THREE.Color(0,1,0);
    OutlinePass.hiddenEdgeColor=new THREE.Color(0,1,0);
    OutlinePass.edgeThickness=3.0;
    var composer=new THREE.EffectComposer(renderer);
    composer.addPass(renderPass);
    composer.addPass(OutlinePass);
    var FXAAShaderPass=new THREE.ShaderPass(THREE.FXAAShader);
    FXAAShaderPass.renderToScreen=true;
    FXAAShaderPass.uniforms['resolution'].value.set(1/ window.innerWidth, 1 /window.innerHeight);
    composer.addPass(FXAAShaderPass);
    var RainGroup=new THREE.Group();

    var clock=new THREE.Clock();
    var FPS=30;
    var T=1/FPS;
    var timeS=0;
    var i=0;
    scene.rotateY(-0.3);
    function render()
    {
        i+=1;
        if(i<300)
        {
            scene.rotateY(0.001)
        }
        requestAnimationFrame(render);
        var deltaT=clock.getDelta();
        timeS=timeS+deltaT;
        if(timeS>T)
        {
            composer.render();
            labelRenderer.render(scene,camera);
            timeS=0;
        }
    }
    render();
    var controls=new THREE.OrbitControls(camera);
    controls.enablePan=false;
    controls.minZoom=0.6;
    controls.maxZoom=3;


    window.onresize=function(){
        renderer.setSize(window.innerWidth,window.innerHeight);
        k=window.innerWidth/window.innerHeight;
        camera.left=-s*k;
        camera.right=s*k;
        camera.top=s;
        camera.bottom=-s;
        camera.updateProjectionMatrix();
        location.reload()
    };
</script>

</body>
</html>